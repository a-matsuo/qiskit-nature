# This code is part of Qiskit.
#
# (C) Copyright IBM 2021, 2022.
#
# This code is licensed under the Apache License, Version 2.0. You may
# obtain a copy of this license in the LICENSE.txt file in the root directory
# of this source tree or at http://www.apache.org/licenses/LICENSE-2.0.
#
# Any modifications or derivative works of this code must retain this
# copyright notice, and modified files need to carry a notice indicating
# that they have been altered from the originals.

"""The Logarithmic Mapper."""

import operator

from fractions import Fraction
from functools import reduce
from typing import List, Union

import numpy as np

from qiskit.opflow import PauliSumOp
from qiskit.quantum_info.operators import SparsePauliOp, Operator
from qiskit_nature.operators.second_quantization import SpinOp
from .spin_mapper import SpinMapper


class LogarithmicMapper(SpinMapper):
    """A mapper for Logarithmic spin-to-qubit mapping [1].


    [1]: Mathis, S. V., Gauglielmo, M., & Ivano, T. (2020).
         Toward scalable simulations of Lattice Gauge Theories on quantum computer.
         `arXiv:2005.10271 <https://arxiv.org/abs/2005.10271>`_
    """

    def __init__(self, embed_padding: float = 1, embed_location: str = "upper") -> None:
        """
        Args:
            embed_padding:
                The value of the diagonal elements of the upper left  block of the embedded matrix.
            embed_location:
                Must be one of ['upper', 'lower']. This parameters sets whether
                the given matrix is embedded in the upper left hand corner or
                the lower right hand corner of the larger matrix.
        """
        super().__init__(allows_two_qubit_reduction=False)
        self._embed_padding = embed_padding
        self._embed_location = embed_location

    def map(self, second_q_op: SpinOp) -> PauliSumOp:
        """Map spins to qubits using the Logarithmic encoding.
        In this local encoding transformation each individual spin S system is represented via
        the lowest lying 2S+1 states in a qubit system with the minimal number of qubits needed to
        represent >= 2S+1 distinct states.

        Args:
            second_q_op: Spins mapped to qubits.

        Returns:
            Qubit operators generated by the Logarithmic encoding
        """
        qubit_ops_list: List[PauliSumOp] = []

        # get logarithmic encoding of the general spin matrices.
        spinx, spiny, spinz, identity = self._logarithmic_encoding(second_q_op.spin)

        for idx, (_, coeff) in enumerate(second_q_op.to_list()):

            operatorlist: List[PauliSumOp] = []

            for n_x, n_y, n_z in zip(second_q_op.x[idx], second_q_op.y[idx], second_q_op.z[idx]):

                operator_on_spin_i: List[PauliSumOp] = []

                if n_x > 0:
                    operator_on_spin_i.append(reduce(operator.matmul, [spinx] * int(n_x)))

                if n_y > 0:
                    operator_on_spin_i.append(reduce(operator.matmul, [spiny] * int(n_y)))

                if n_z > 0:
                    operator_on_spin_i.append(reduce(operator.matmul, [spinz] * int(n_z)))

                if np.any([n_x, n_y, n_z]) > 0:
                    single_operator_on_spin_i = reduce(operator.matmul, operator_on_spin_i)
                    operatorlist.append(single_operator_on_spin_i.reduce())

                else:
                    # If n_x=n_y=n_z=0, simply add the embedded Identity operator.
                    operatorlist.append(identity)

            # Now, we can tensor all operators in this list
            qubit_ops_list.append(coeff * reduce(operator.xor, reversed(operatorlist)))

        qubit_op = reduce(operator.add, qubit_ops_list)

        return qubit_op

    def _logarithmic_encoding(self, spin: Union[Fraction, float]) -> List[PauliSumOp]:
        """The logarithmic encoding.

        Args:
            spin: Positive half-integer (integer or half-odd-integer) that represents spin.

        Returns:
            A list of PauliSumOp for qubit operators
        """
        spin_op_encoding: List[PauliSumOp] = []
        dspin = int(2 * spin + 1)
        num_qubits = int(np.ceil(np.log2(dspin)))

        # Get the spin matrices
        spin_matrices = [np.asarray(SpinOp(symbol, spin=spin).to_matrix()) for symbol in "XYZ"]
        # Append the identity
        spin_matrices.append(np.eye(dspin))

        # Embed the spin matrices in a larger matrix of size 2**num_qubits x 2**num_qubits
        embed = lambda matrix: self._embed_matrix(
            matrix,
            num_qubits,
            embed_padding=self._embed_padding,
            embed_location=self._embed_location,
        )
        embedded_spin_matrices = list(map(embed, spin_matrices))

        # Generate operators from these embedded spin matrices
        embedded_operators = [Operator(matrix) for matrix in embedded_spin_matrices]
        for op in embedded_operators:
            op = SparsePauliOp.from_operator(op)
            op.chop()
            spin_op_encoding.append(PauliSumOp(1.0 * op))

        return spin_op_encoding

    def _embed_matrix(
        self,
        matrix: np.ndarray,
        num_qubits: int,
        embed_padding: float = 1,
        embed_location: str = "upper",
    ) -> np.ndarray:
        """
        Embeds `matrix` into the upper/lower diagonal block of a 2^num_qubits by 2^num_qubits matrix
        and pads the diagonal of the upper left block matrix with the value of `embed_padding`.
        Whether the upper/lower diagonal block is used depends on `embed_location`.
        I.e. using embed_location = 'upper' returns the matrix:
            [[ matrix,    0             ],
            [   0   , embed_padding * I]]
        Using embed_location = 'lower' returns the matrix:
            [[ embed_padding * I,    0    ],
            [      0           ,  matrix ]]
        Args:
            matrix: The matrix (2D-array) to embed.
            num_qubits: The number of qubits on which the embedded matrix should act on.
            embed_padding:
                The value of the diagonal elements of the upper left block of the embedded matrix.
            embed_location: Must be one of ['upper', 'lower']. This parameters sets
                whether the given matrix is embedded in the
                upper left hand corner or the lower right hand corner of the larger matrix.

        Returns:
            If `matrix` is of size 2^num_qubits, returns `matrix`.
            Else it returns the block matrix (I = identity)
            [[ embed_padding * I,    0    ],
            [      0           , `matrix`]]

        Raises:
            ValueError: If embed_location is neither "upper" nor "lower".
            ValueError: If the passed matrix does not fit into the space spanned by num_qubits.
        """
        full_dim = 1 << num_qubits
        subs_dim = matrix.shape[0]

        dim_diff = full_dim - subs_dim
        if dim_diff == 0:
            full_matrix = matrix

        elif dim_diff > 0:
            if embed_location == "lower":
                full_matrix = np.zeros((full_dim, full_dim), dtype=complex)
                full_matrix[:dim_diff, :dim_diff] = np.eye(dim_diff) * embed_padding
                full_matrix[dim_diff:, dim_diff:] = matrix

            elif embed_location == "upper":
                full_matrix = np.zeros((full_dim, full_dim), dtype=complex)
                full_matrix[:subs_dim, :subs_dim] = matrix
                full_matrix[subs_dim:, subs_dim:] = np.eye(dim_diff) * embed_padding

            else:
                raise ValueError("embed_location must be one of upper or lower")

        else:
            raise ValueError(
                f"The given matrix does not fit into the space spanned by {num_qubits} qubits."
            )

        return full_matrix
